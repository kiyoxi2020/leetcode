# 算法

[TOC]



## 1. 贪心算法：每次操作都是局部最优，且局部最优保证全局最优

### 1.1 分配问题

- leetcode 455：饼干分配，[a1, a2, a3,..., an]表示n个孩子的饥饿度，[b1, b2,..., bm]表示m个饼干的大小，问把饼干分给孩子，最多可以填饱多少个孩子？

	- 解法：为使填饱的孩子尽量多，先满足容易吃饱的孩子（拿尽量小的饼干），然后循环操作

- leetcode 135：糖果分配（hard），[a1, a2, ..., an]表示n个孩子的评分，分配糖果的规则为：评分比身旁孩子高的得到更多糖果，所有孩子至少有一个糖果，问最少需要多少糖果？

	- 解法：先从左往右遍历，满足比左边评分高则分到的糖果多，再从右往左遍历，满足比右边评分高则分到的糖果多（两次遍历）

### 1.2 区间问题

- leetcode 435：给定多个区间[[a1, b1], [a2, b2], ..., [an, bn]]，计算让这些区间互不重叠需要移除的最小区间数

	- 解法：按区间结尾从小到大排序，然后从左往右遍历，若与前一个已选择的区间不重叠，则加入选择，否则跳过

### 1.3 练习

- leetcode 605、452、763、122、406、665

## 2. 指针

### 2.1 双指针、滑动窗口

- leetcode 167：两数之和II，在增序整数数组中找到两个数，使它们的和为给定值

	- 解法：采用双指针，st从最左边开始，ed从最右边开始，若两者和等于目标，则返回，若小于目标，则st+1，若大于目标，则ed-1

- leetcode 88：归并两个有序数组，给定两个有序数组，把两个数组合并为一个有序数组

	- 解法：把两个指针放在末尾，选择较大的数字放在nums1后面，对应指针前移一位

- leetcode 76：最小覆盖子串，给定两个字符串S、T，求S中包含T所有字符的最短连续子字符串的长度

	- 解法：把两个指针l、r放在开头，移动过程中l<=r，r右移，直到包含T中所有字符，记录长度，此时l右移，直到遇到下一个T中的字符，循环迭代

### 2.2 快慢指针

- leetcode 142：环形链表II，给定一个链表，返回环路开始的点，如果没有环路则返回空指针

	- 解法：快慢指针（Floyd 判圈法）

### 2.3 练习

- leetcode 633、680、524、340

## 3. 二分查找：对于长度为O(n)的数组，二分查找的时间复杂度为O(log n)，维护st、ed、mid

- leetcode 69: 求开方，给定一个非负整数a，求它的开方
  - 解法：在[0,a]之间二分搜索，找到满足条件的数

- leetcode 34：给定一个升序的整数数组，查找目标值第一次和最后一次出现的位置
  - 解法：两次二分搜索，分别找到lower_bound和upper_bound

- leetcode 81：旋转数组查找数字，给定一个值，判断该值是否存在于旋转数组中
  - 解法：对于当前mid，若小于右端，则说明右区间是排好序的，反之，说明左区间是排好序的，若目标值位于排好序的区间，则对排好序的区间进行二分查找，否则对另一个区间进行二分查找

### 练习

- leetcode 154、540、4

## 4. 排序算法

### 4.1 常用排序算法

- 冒泡排序（BubbleSort）

	- 算法：一个一个比较，把大的换到右边，每次迭代都把当前段最大的放在右边，可以提前终止

- 插入排序（InsertSort）

	- 算法：维护最左侧的升序，一旦遍历新的数，把它往前放，直到放到满足升序的位置，即插入到合适的位置

- 选择排序（SelectionSort）

	- 算法：遍历选择该段中最小的数，放到最左边

- 归并排序（MergeSort）

	- 算法：递归，先从中间拆成二叉树，直到叶子节点，然后依次往上按序归并，直到根节点，完成排序

- 堆排序

	- 算法：构造最大堆，对于数组[a1, a2, a3, a4, a5..., an]，表示树a1下接a2、a3，a2下接a4、a5等等，从根节点开始往上，把大的往上挪，保证每个子树根节点比叶子节点都大，然后将根节点与最后的叶子节点交换，再循环

- 快速排序 (QuickSort)

	- 算法：双指针，固定最后一个数，取l为最左边，r为倒数第二个数，若l小于右端数，则l+1，直到l大于右端，若r大于右端数，则r-1，直到r小于右端数，此时交换l、r的数，若l=r，则把该数与右端数交换，对左半边、右半边分别进行同样的双指针操作

		- leetcode 215：数组中的第K个最大元素

			- 解法：可以先排序，后取倒数第K个；更快地，采用快排可以确定右端元素的下标，保证左边的都小于它，右边的都大于它，一旦下标为n-K，则返回，否则选择递归左边或者右边

- 桶排序

	- leetcode 347：前K个高频元素，给定整数数组[a1, a2, ..., an]，返回其中出现频率前k次的元素

		- 解法：首先使用哈希表dict记录每个元素出现的次数，然后可以对次数进行桶排序，桶的数量为最大次数，然后依次将该次数对应的元素填入同，从后往前遍历桶，得出k个元素

### 4.2 练习

- leetcode 451、75

## 5. 搜索

### 5.1 深度优先搜索（DFS）：在搜索到一个节点之后，立即对该节点进行遍历，即先入后出的栈

- leetcode 695：岛屿的最大面积，给定二维的0-1矩阵，求最大岛屿面积，考虑四邻域

	- 解法：遍历找到1，可以开始搜索的点，然后从该点开始dfs，记录面积，记录搜索过的点，直到没有可以搜索的点，则返回，继续寻找下一个可以开始搜索的点

- leetcode 547：省份数量，给定一个二维的0-1矩阵，若位置(i,j)=1，说明i城市和j城市相连，且相连关系可以传递，相连的城市处于同一个省，问共有多少个省

	- 解法：从第1个城市开始，dfs直到没有相邻的城市，记录搜索过的点，省份数量+1，然后寻找下一个没有搜索过的城市开始搜索

- leetcode 417：太平洋大西洋水流问题，给定一个二维非负矩阵，每个值表示海拔高度，假设左边、上边是太平洋，右边、下边是大西洋，求从哪些位置下流水，可以流到太平洋和大西洋，水只能从海拔高的位置流到海拔低的或者相同的位置

	- 解法：反向思考，水往上流，从岸边开始搜索水往上流能够到达的位置，最后取两个洋都能到达的位置即可

### 5.2 回溯：在递归搜索的基础上，需要进行退回操作，把目前节点修改的状态还原，即所有的状态修改在递归完成后回改

- leetcode 46：全排列，给定一个不含重复数字的数组nums，返回其所有可能的全排列

	- 解法：遍历每个数字，从各个数字开始，继续遍历剩下的每个数字，dfs，递归返回后，将刚才加入的数字删除，回退，继续遍历下一个

- leetcode 77：组合，给定两个整数n、k，返回1...n中所有可能的k个数的组合

	- 解法：遍历数字i，加入组合，从i+1开始继续遍历，加入组合，递归直到数量为k，此时递归返回，将刚才加入的数字删除，回退，继续遍历下一个

- leetcode 79：单词搜索，给定一个字母矩阵，给定一个字符串，求字符串是否能在字母矩阵中找到

	- 解法：找到开头字母，开始向四个方向遍历，直到找到与第二个字母相同的，继续遍历，以第二个字母为开始点，向四个方向遍历，直到结束，递归返回后，将刚才找到的数字删除，遍历下一个

- leetcode 51：N皇后，给定一个大小为n的正方形国际象棋棋盘，求有多少种方式可以放置n个皇后，使得她们不能相互攻击，即每一行，每一列，左斜，右斜最多只有一个皇后，返回所有可能解法

	- 解法：依次遍历每个位置，一旦放置一个皇后之后，标注不能放置的位置，然后遍历下一个，直到返回，递归返回后，将刚才放置的皇后、标注的位置都删除，遍历下一个

### 5.3 广度优先搜索（BFS）：一层一层遍历，用先入先出的队列进行遍历，按照层次进行遍历，常用于解决最短路径问题

- leetcode 934：最短的桥，在给定二维0-1数组中，存在两座道，可以将0变为1，将两座岛连接起来，求必须翻转的0的最小数目

	- 解法：首先通过dfs找到两座岛，然后选择任意一座岛，开始bfs，直到找到令一座岛，此时进行的bfs的次数即为翻转的最小数目

- leetcode 126：单词接龙，给定一个起始字符串、一个终止字符串，以及一个单词表，求是否可以将起始字符串每次改一个字符，直到改成终止字符串，且所有修改过程表示的字符串都可以在单词表找到，返回更改方式

	- 解法：首先建图，表示单词表节点之间的关系，然后从起始字符串开始bfs搜索，直到找到目标字符，注意不能循环，递归返回时，将加入的字符串删除，标记数组中对应位置删除，继续遍历下一个（回溯+bfs）

### 5.4 练习

- leetcode：130、257、47、40、37、310

## 6. 动态规划：转移状态方程、状态记录（保留子问题的解，避免重复计算）、有最优子结构（局部最优解能得到全局最优解）

### 6.1 基本一维

- leetcode 70：爬楼梯，给定n节台阶，每次可以走一步或者两步，求一共有多少种方式可以走完台阶

	- 解法：1、找到转移方程：dp[i]=dp[i-1]+dp[i-2]；2、使用dp而不是递归求解

- leetcode 198：打家劫舍，数组[a1, a2, .., an]表示街上房子的钱财数量，如果抢劫了连续两间房子，会触发警报机关，求不触发机关的情况下可以抢劫多少钱

	- 解法：1、定义dp[i]为到i个房间为止抢劫的最大金额；2、找到转移方程：dp[i]=max(dp[i-2]+ai, dp[i-1])；3、dp求解

- leetcode 413：等差数列划分，给定一个数组，求这个数组中连续且等差的子数组一共有多少个

	- 解法：1、定义dp[i]表示以i结尾的等差数列的数量；2、转移方程：dp[i]=dp[i-1]+nums[i] if nums[i]-nums[i-1]==nums[i-1]-nums[i-2]；3、dp求解

### 6.2 基本二维

- leetcode 64：给定一个m×n的非负矩阵，求从左上角到右下角，经过数字和最小的路径，且每次只能向右或者向下移动

	- 解法：1、定义dp[i][j]表示从左上角到nums[i][j]的最小路径；2、转移方程：dp[i][j]=min(dp[i-1][j], dp[i][j-1])+nums[i][j]；3、dp求解

- leetcode 542：01矩阵，给定一个0-1矩阵，求每个位置到最近0的距离

	- 解法1：遍历+bfs+记忆
	- 解法2：1、定义dp[i][j]为到0的最近距离；
2、从左上角到右下角搜索，dp[i][j]=min(dp[i-1][j], dp[i][j-1])+1 if nums[i][j]==1, else dp[i][j]=0；
3、从右下角到左上角遍历，dp[i][j]=min(dp[i][j], dp[i][j+1], dp[i+1][j])+1 if nums[i][j]==1, else dp[i][j]=0

- leetcode 221：最大正方形，在0-1矩阵中，找到只包含1的最大正方形，并返回面积

	- 解法：1、dp[i][j]表示以位置i、j为右下角的矩阵的最大边长；2、dp[i][j]=min(dp[i-1][j], dp[i][j-1]+1 if nums[i][j]==1 else 0；3、返回最大值

### 6.3 分割类型题

- leetcode 279：完全平方数，给定一个正整数，求其最少可以由几个完全平方数相加构成

	- 解法：1、dp[i]表示数字i最多可以有几个完全平方数相加构成；2、dp[i]=min(dp[i-1]+1,dp[i-4]+1,dp[i-9]+1,....)；

- leetcode 91：解码方法，有编码规则：A->1, B->2,..., Z->26，要解码已编码的信息，比如"11014"，求共有几种解码方法

	- 解法：1、dp[i]表示前i个字符对应的解码方案；2、dp[i]=...

- leetcode 139：单词拆分，给定一个字符串s和一个单词列表wordDict，判断s是否可以拆分成多个字典中出现的单词

	- 解法：1、dp[i]表示到i为止的字符串是否可以被拆分；2、dp[i] = max(dp[i-len] if s[i-len+1:i+1] in wordDict)

### 6.4 子序列问题

- leetcode 300：最长递增子序列，给定一个未排序的整数数组，求最长递增子序列

	- 解法：1、dp[i]表示以i结尾的最长递增子序列；2、dp[i]=max(dp[i-k]+1 if s[i]>s[i-k])

- leetcode 1143：最长公共子序列，给定两个字符串s1, s2，求它们的最长公共子序列

	- 解法：1、dp[i][j]表示s1到i位置，s2到j位置的最长公共子序列长度；2、dp[i][j]=max(dp[i-1][j-1]+1 if s1[i]==s2[j], else dp[i-1][j], dp[i][j-1])

### 6.5 背包问题

- 0-1背包问题：有N个物体，每个物体的体积为w、价值为v，背包容量为W，求问拿哪些物体可以使背包装下的价值最大，每个物体只能拿0个或1个

	- 解法：1、dp[i][j]表示容量i、使用前j个物体，能装下的最大价值；
2、dp[i][j]=max(dp[i-w[j]][j-1]+v[j], dp[i][j-1])，分别对应取1个j，取0个j

		- leetcode 416：分割等和子集，给定一个正整数数组，求是否可以把这个数组分成和相等的两部分

			- 解法：相当于0-1背包问题，背包容量为sum/2，看是否有组合方式能够达到sum/2；
1、dp[i][j]表示使用前j个数是否能得到和i；
2、dp[i][j]=max(dp[i-nums[j]][j-1], dp[i][j-1])
【可以进一步把j维压缩掉，i维从后往前遍历】

		- leetcode 474：一和零，给定m个数字0、n个数字1，以及一些由0-1构成的字符串，求利用这些数字最多可以构成多少个给定的字符串，且字符串只可以构成一次

			- 解法：三维0-1背包问题，对字符串进行0-1选择，可以将三维压缩成二维
1、 dp[i][j]表示使用i个0，j个1能够组成多少个前t个字符串；
2、dp[i][j][t]=max(dp[i-num_0[t]][j-num_0[t]][t-1]+1, dp[i][j][t-1])

- 完全背包问题：不限制拿物体的个数

	- 解法：1、dp[i][j]表示容量i、使用前j个物体，能够装下的最大价值；
2、dp[i][j]=max(dp[i-w[j]][j]+v[j]，dp[i][j-1])，分别对应再取1个j，不取j

		- leetcode 322：零钱兑换，给定一些硬币的面额coins，求最少可以用多少颗硬币组成给定的金额amount

			- 解法：完全背包问题，对硬币进行选择
1、dp[i][j]表示给定金额i，前j个硬币，最少需要多少个硬币
2、dp[i][j]=min(dp[i-coins[j]][j]+1, dp[i][j-1])

### 6.7 字符串编辑

- leetcode 72：编辑距离，给定两个字符串word1、word2，可以删除、替换、插入任意字符串的任意字符，求最少编辑几步可以将两个字符串变成相同

	- 解法：1、dp[i][j]表示使用word1前i个、word2前j个，最少需要编辑几步；
2、dp[i][j]=min(dp[i-1][j-1] if word[i]==word[j] else dp[i-1][j-1]+1, dp[i-1][j]+1, dp[i][j-1]+1)

- leetcode 650：只有两个键的键盘，给定一个字母A，可以每次选择复制全部字符，或者粘贴之前复制的字符，求最少需要几次操作，才能把字符串延展到指定长度

	- 解法：1、dp[i]表示延展到长度i所需的最少操作数；2、dp[i]=min( dp[i/j]+dp[j], j=1,2,...)

- leetcode 10：正则表达式匹配，给定一个字符串s，和一个字符串规律p，实现一个支持.、*的正则表达式，其中，.可以匹配任意单个字符，*可以匹配零个或多个前面的元素

	- 解法：1、dp[i][j]表示前i个字符串，前j个字符串规律是否可以匹配；
2、dp[i][j]=max(if ...)

### 6.8 股票交易

- leetcode 121：买卖股票的最佳时机，给定一段时间内每天的股票价格，可以买卖各一次，求最大收益

	- 解法：1、dp[i]表示前i天中的最低价格；
2、dp[i]=min(dp[i], prices[i])，取max(prices[i]-dp[i])
	- 解法：1、buy[i]表示第i天买入的最大收入，sell[i]表示第i天买入的最大手术；
2、buy[i]=max(buy[i-1], -prices[i])；sell[i]=max(buy[i-1], buy[i-1]+prices[i])

- leetcode 188：买卖股票的最佳时机IV，给定一段时间内每天的股票价格，可以买卖各k次，且每次只能拥有一支股票，求最大收益

	- 解法：1、buy[i][j]表示前j天，第i次买入的最大收入，sell[i][j]表示前j天，第i次卖出的最大收入；
2、buy[i][j]=max(buy[i][j-1], sell[i-1][j-1]-prices[j]); sell[i][j]=max(sell[i][j-1], buy[i][j-1]+prices[j])

- leetcode 309：买卖股票的最佳时期 含冷冻期，给定一段时间内每天的股票价格，已知每次卖出之后必须冷却一天，且每次只能拥有一支股票，求最大收益

	- 解法：1、buy[i]表示第i天买入的最大收入，sell[i]表示第i天卖出的最大收入，s1[i]表示第i天冷却的最大收入；
2、buy[i]=max(buy[i-1], s1[i-1]-prices[i])；sell[i]=max(sell[i-1], buy[i-1]+prices[i])；s1=max(s1[i-1], sell[i-1])

### 6.9 练习

- leetcode 213、53、343、583、646、376、494、714

## 7. 分治与递归：分（divide）、治（conquer），把原问题分为子问题，再将子问题进行合并，从而实现对原问题的求解，比如归并排序

- leetcode 241：为运算表达式设计优先级，给定一个包含数字、运算符的字符串，为表达式添加括号，改变运算优先级以求出不同的结果，需要给出所有可能的组合结果，有效的运算符包含+、-、*
  - 解法：先按照运算符，将原问题划分为左边、右边两个子问题（divide），得到左边的可能结果的list、右边可能结果的list，再将两者组合（conquer），得到最终可能结果

### 练习

- leetcode 932、312

## 8. 其他

### 8.1 数学问题

### 8.2 位运算

### 8.3 数据结构

- 数组
- 栈和队列
- 优先队列
- 双端队列
- 哈希表
- 多重集合和映射
- 前缀和积分图
- 练习

### 8.4 字符串

### 8.6 指针三剑客

- 链表
- 树
- 图

### 8.7 复杂数据结构

- 并查集
- 复合数据结构



